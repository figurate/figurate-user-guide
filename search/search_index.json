{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Figurate is a collection of patterns and concerns relevant to the operation of modern software systems. Figurate promotes the design principles of modularity and separation of concerns , such that the cognitive load of managing individual software components is reduced. Whilst modularity and loose coupling are recognised as good tenents of software design, it is also just as valid when considering the wider DevOps ecosystem. Whether you look towards Platform Engineering, Golden Path or something else, these are all just implementations of separation of concerns and loose coupling. Security Reliability Efficiency Operational Excellence Cost Optimization Sustainability Tenant management Identity Management Permissions Certificates Encryption Secrets Threats Audit Usage monitoring Throttling Backups - Logging Routing Vulnerabilities Service Quotas - - Monitoring Networking Serverless - - - Alerting Tracing - - - - Observability - - - - - Beginning with the top left of the Figurate table, and working across and down, we can address each of the concerns specific to an application, platform or organisation. Where the application(s) are hosted is an obvious primary concern, so we consider tenancy management as a starting point for any workload. Identity is also an important concern for any workload, as it relates not just to application users but also mantainers. Threat detection and identification is also an important concern for all workloads, especially when operating in public environments (i.e. Cloud). Figurate Maturity Model Whilst there are many concerns when operating modern software, it is also true that it isn't realistic to be able to address all of them sufficiently on day one. The Figurate Maturity Model identifies levels of maturity when addressing key concerns, such that you may consider at a minimum what should be implemented based on the type of workload. It is also true that some concerns may not even be supported by the target environment or platform, but ultimately this model is a general guide provided to address concerns where applicable.","title":"Introduction"},{"location":"#introduction","text":"Figurate is a collection of patterns and concerns relevant to the operation of modern software systems. Figurate promotes the design principles of modularity and separation of concerns , such that the cognitive load of managing individual software components is reduced. Whilst modularity and loose coupling are recognised as good tenents of software design, it is also just as valid when considering the wider DevOps ecosystem. Whether you look towards Platform Engineering, Golden Path or something else, these are all just implementations of separation of concerns and loose coupling. Security Reliability Efficiency Operational Excellence Cost Optimization Sustainability Tenant management Identity Management Permissions Certificates Encryption Secrets Threats Audit Usage monitoring Throttling Backups - Logging Routing Vulnerabilities Service Quotas - - Monitoring Networking Serverless - - - Alerting Tracing - - - - Observability - - - - - Beginning with the top left of the Figurate table, and working across and down, we can address each of the concerns specific to an application, platform or organisation. Where the application(s) are hosted is an obvious primary concern, so we consider tenancy management as a starting point for any workload. Identity is also an important concern for any workload, as it relates not just to application users but also mantainers. Threat detection and identification is also an important concern for all workloads, especially when operating in public environments (i.e. Cloud).","title":"Introduction"},{"location":"#figurate-maturity-model","text":"Whilst there are many concerns when operating modern software, it is also true that it isn't realistic to be able to address all of them sufficiently on day one. The Figurate Maturity Model identifies levels of maturity when addressing key concerns, such that you may consider at a minimum what should be implemented based on the type of workload. It is also true that some concerns may not even be supported by the target environment or platform, but ultimately this model is a general guide provided to address concerns where applicable.","title":"Figurate Maturity Model"},{"location":"digitalocean/","text":"Digital Ocean","title":"Digital Ocean"},{"location":"digitalocean/#digital-ocean","text":"","title":"Digital Ocean"},{"location":"identity/","text":"Identity and Access Management This page explores key concepts with user authentication, identity and access management. Overview TBD. AWS Cognito TBD. References: AWS Well Architected - Identity Management","title":"Identity Management"},{"location":"identity/#identity-and-access-management","text":"This page explores key concepts with user authentication, identity and access management.","title":"Identity and Access Management"},{"location":"identity/#overview","text":"TBD.","title":"Overview"},{"location":"identity/#aws-cognito","text":"TBD.","title":"AWS Cognito"},{"location":"identity/#references","text":"AWS Well Architected - Identity Management","title":"References:"},{"location":"tenancy/","text":"Tenancy management Tenancy management is concerned with how you manage access and isolation of workloads. Maturity Model Tenancy maturity considers the complexity of a hosting platform, and ability to support secondary concerns. For example, Digital Ocean is a public Cloud platform without fine-grained auditing, so it may be classified as a low maturity platform. For some workloads this may be sufficient, but for others a more sophisticated (and costly) target platform may be required. Low - Network Isolation Medium - Role-based Access High - Auditing and Logging support References: AWS Well Architected - Account Management and Separation","title":"Tenant Management"},{"location":"tenancy/#tenancy-management","text":"Tenancy management is concerned with how you manage access and isolation of workloads.","title":"Tenancy management"},{"location":"tenancy/#maturity-model","text":"Tenancy maturity considers the complexity of a hosting platform, and ability to support secondary concerns. For example, Digital Ocean is a public Cloud platform without fine-grained auditing, so it may be classified as a low maturity platform. For some workloads this may be sufficient, but for others a more sophisticated (and costly) target platform may be required. Low - Network Isolation Medium - Role-based Access High - Auditing and Logging support","title":"Maturity Model"},{"location":"tenancy/#references","text":"AWS Well Architected - Account Management and Separation","title":"References:"},{"location":"threats/","text":"Threat detection and response This page outlines strategies to detect threats and how to respond. References AWS Well Architected - Investigate","title":"Threat Identification"},{"location":"threats/#threat-detection-and-response","text":"This page outlines strategies to detect threats and how to respond.","title":"Threat detection and response"},{"location":"threats/#references","text":"AWS Well Architected - Investigate","title":"References"},{"location":"modularity/","text":"Modular Architectures Application architectures must continually evolve and grow not only to meet future needs but to stay relevant and secure in an ecosystem that is continually changing. Because of the need for constant growth a monolithic architecture will eventually become very difficult to maintain in both size and complexity. For this reason modular architectures make more sense for even the smallest applications to be able to not only manage components independently, but to allow for upgrade and replacement of different components over time.","title":"Overview"},{"location":"modularity/#modular-architectures","text":"Application architectures must continually evolve and grow not only to meet future needs but to stay relevant and secure in an ecosystem that is continually changing. Because of the need for constant growth a monolithic architecture will eventually become very difficult to maintain in both size and complexity. For this reason modular architectures make more sense for even the smallest applications to be able to not only manage components independently, but to allow for upgrade and replacement of different components over time.","title":"Modular Architectures"},{"location":"modularity/docker/iac/","text":"Docker Docker is the most popular incarnation of the Container-as-a-Service (CaaS) application model, whereby applications are packaged and executed in isolated containers. Docker is extremely versatile in that it supports any language or application that runs on Linux, resulting modern applications that can be designed as a collection of modular containers that integrate to form robust and easy to maintain architectures.","title":"Docker"},{"location":"modularity/docker/iac/#docker","text":"Docker is the most popular incarnation of the Container-as-a-Service (CaaS) application model, whereby applications are packaged and executed in isolated containers. Docker is extremely versatile in that it supports any language or application that runs on Linux, resulting modern applications that can be designed as a collection of modular containers that integrate to form robust and easy to maintain architectures.","title":"Docker"},{"location":"modularity/lambda/","text":"Lambda AWS Lambda is the most popular implementation of Function as a service (FaaS), whereby loosely-coupled functions are deployed and managed independently. The primary benefit of Lambda is that there are no hosts that need patching and maintenance, allowing the DevOps team to focus entirely on the application (function) code.","title":"Introduction"},{"location":"modularity/lambda/#lambda","text":"AWS Lambda is the most popular implementation of Function as a service (FaaS), whereby loosely-coupled functions are deployed and managed independently. The primary benefit of Lambda is that there are no hosts that need patching and maintenance, allowing the DevOps team to focus entirely on the application (function) code.","title":"Lambda"},{"location":"modularity/osgi/","text":"Introduction The Open Services Gateway Initiative (OSGi) is a plugin architecture for composing Java applications. OSGi is an \"in-process\" approach to modularity such that components share the same application memory, etc. Pros The benefits of an in-process modular architecture like OSGi typically relate to performance and security concerns. In-process communication is more efficient than out-of-process Less need for authentication/encryption of inter-component communication Cons Whilst OSGi may be considered as a modular architecture it is still a more tightly-coupled approach than out-of-process architectures. Restricted to Java-based components that can run in-process Whilst theoretically can replace/upgrade components at run-time, still requires redeploy for major changes","title":"Introduction"},{"location":"modularity/osgi/#introduction","text":"The Open Services Gateway Initiative (OSGi) is a plugin architecture for composing Java applications. OSGi is an \"in-process\" approach to modularity such that components share the same application memory, etc.","title":"Introduction"},{"location":"modularity/osgi/#pros","text":"The benefits of an in-process modular architecture like OSGi typically relate to performance and security concerns. In-process communication is more efficient than out-of-process Less need for authentication/encryption of inter-component communication","title":"Pros"},{"location":"modularity/osgi/#cons","text":"Whilst OSGi may be considered as a modular architecture it is still a more tightly-coupled approach than out-of-process architectures. Restricted to Java-based components that can run in-process Whilst theoretically can replace/upgrade components at run-time, still requires redeploy for major changes","title":"Cons"},{"location":"modularity/osgi/getting-started/","text":"Getting Started The Figurate Guide provides documentation to assist with getting the most out of the Figurate framework. Getting Started Launcher Components Constellations Getting Started The following instructions will help you to get a Figurate project up and running as quickly as possible. Gradle Plugin The simplest way to use Figurate is to apply the Figurate plugin in a Gradle build script. Some example applications are provided that demonstrate usage of this plugin. Launcher The Figurate Launcher is a convenient way to configure the bootstrap of the underlying OSGi platform. Startup Configuration Bundles Start Levels Components Figurate provides configuration via the OSGi standard Configuration Admin support. Component Configuration Factory Configuration Constellations A Figurate Constellation is a collection of bundles that are designed to work together to provide a specific feature. The available Figurate constellations are as follows: | Constellation | Figurate Versions | Description |- | felix | All | Felix OSGi runtime | http | All | HTTP server/Servlet container (Jetty) | scr | All | Service Component Runtime | webconsole | All | Felix OSGi dashboard Gradle Plugin Figurate provides a gradle plugin to make it simple to add constellations to your application, without needing to worry about compatibility issues between bundles across different constellations. You apply the constellation plugin as follows: apply plugin: 'constellations' Configurations The Gradle Constellation Plugin uses Gradle configurations to define constellations. As such, to add a constellation to your application you just include the configuration in Figurate's custom bundle configuration, like so: bundle constellation$felix You can also make use of Gradle's dependency tools to query the actual bundles included in a given constellation: gradle dependencies --configuration constellation\\$felix Note that as Figurate constellations are defined using a dollar ($) symbol, some shells may try to apply variable substitution, which is why we need to escape the dollar. The output should look something like this: {% highlight bash %} \\$ gradle dependencies --configuration constellation\\$felix :feed-aggregator:dependencies Project :feed-aggregator constellation$felix +--- org.apache.felix:org.apache.felix.dependencymanager:4.0.1 +--- org.apache.felix:org.apache.felix.http.bundle:2.2.2 +--- org.apache.felix:org.apache.felix.log:1.0.1 +--- org.apache.felix:org.apache.felix.scr:1.8.2 +--- org.osgi:org.osgi.compendium:4.2.0 --- org.apache.felix:org.apache.felix.configadmin:1.8.0 BUILD SUCCESSFUL Total time: 6.027 secs {% endhighlight %}","title":"Getting Started"},{"location":"modularity/osgi/getting-started/#getting-started","text":"The Figurate Guide provides documentation to assist with getting the most out of the Figurate framework. Getting Started Launcher Components Constellations","title":"Getting Started"},{"location":"modularity/osgi/getting-started/#getting-started_1","text":"The following instructions will help you to get a Figurate project up and running as quickly as possible.","title":"Getting Started"},{"location":"modularity/osgi/getting-started/#gradle-plugin","text":"The simplest way to use Figurate is to apply the Figurate plugin in a Gradle build script. Some example applications are provided that demonstrate usage of this plugin.","title":"Gradle Plugin"},{"location":"modularity/osgi/getting-started/#launcher","text":"The Figurate Launcher is a convenient way to configure the bootstrap of the underlying OSGi platform.","title":"Launcher"},{"location":"modularity/osgi/getting-started/#startup-configuration","text":"","title":"Startup Configuration"},{"location":"modularity/osgi/getting-started/#bundles","text":"","title":"Bundles"},{"location":"modularity/osgi/getting-started/#start-levels","text":"","title":"Start Levels"},{"location":"modularity/osgi/getting-started/#components","text":"Figurate provides configuration via the OSGi standard Configuration Admin support.","title":"Components"},{"location":"modularity/osgi/getting-started/#component-configuration","text":"","title":"Component Configuration"},{"location":"modularity/osgi/getting-started/#factory-configuration","text":"","title":"Factory Configuration"},{"location":"modularity/osgi/getting-started/#constellations","text":"A Figurate Constellation is a collection of bundles that are designed to work together to provide a specific feature. The available Figurate constellations are as follows: | Constellation | Figurate Versions | Description |- | felix | All | Felix OSGi runtime | http | All | HTTP server/Servlet container (Jetty) | scr | All | Service Component Runtime | webconsole | All | Felix OSGi dashboard","title":"Constellations"},{"location":"modularity/osgi/getting-started/#gradle-plugin_1","text":"Figurate provides a gradle plugin to make it simple to add constellations to your application, without needing to worry about compatibility issues between bundles across different constellations. You apply the constellation plugin as follows: apply plugin: 'constellations'","title":"Gradle Plugin"},{"location":"modularity/osgi/getting-started/#configurations","text":"The Gradle Constellation Plugin uses Gradle configurations to define constellations. As such, to add a constellation to your application you just include the configuration in Figurate's custom bundle configuration, like so: bundle constellation$felix You can also make use of Gradle's dependency tools to query the actual bundles included in a given constellation: gradle dependencies --configuration constellation\\$felix Note that as Figurate constellations are defined using a dollar ($) symbol, some shells may try to apply variable substitution, which is why we need to escape the dollar. The output should look something like this: {% highlight bash %} \\$ gradle dependencies --configuration constellation\\$felix :feed-aggregator:dependencies","title":"Configurations"},{"location":"modularity/osgi/getting-started/#project-feed-aggregator","text":"constellation$felix +--- org.apache.felix:org.apache.felix.dependencymanager:4.0.1 +--- org.apache.felix:org.apache.felix.http.bundle:2.2.2 +--- org.apache.felix:org.apache.felix.log:1.0.1 +--- org.apache.felix:org.apache.felix.scr:1.8.2 +--- org.osgi:org.osgi.compendium:4.2.0 --- org.apache.felix:org.apache.felix.configadmin:1.8.0 BUILD SUCCESSFUL Total time: 6.027 secs {% endhighlight %}","title":"Project :feed-aggregator"},{"location":"modularity/osgi/release-notes/","text":"figurate-core","title":"Release Notes"},{"location":"orchestration/","text":"Orchestration Orchestration is the higher level coordination of automated tasks that define a process. Whilst we can automate infrastructure provisioning and deployment of modular architectures, orchestration defines the processes required to ensure these tasks are performed in a safe and orderly fashion.","title":"Overview"},{"location":"orchestration/#orchestration","text":"Orchestration is the higher level coordination of automated tasks that define a process. Whilst we can automate infrastructure provisioning and deployment of modular architectures, orchestration defines the processes required to ensure these tasks are performed in a safe and orderly fashion.","title":"Orchestration"},{"location":"orchestration/gradle/","text":"Gradle Whilst Gradle is technically not an Orchestration tool, the extensive suite of plugins means that it is quite a versatile tool that can be used as part of an orchestrated process.","title":"Overview"},{"location":"orchestration/gradle/#gradle","text":"Whilst Gradle is technically not an Orchestration tool, the extensive suite of plugins means that it is quite a versatile tool that can be used as part of an orchestrated process.","title":"Gradle"},{"location":"terraform/","text":"Figurate Terraform Introduction Terraform is an infrastructure provisioning tool that defines a language that allows for declarative definition of infrastructure resources in a concise format. The power of Terraform is in the extensive list of provider plugins that implement integration with multiple Cloud platforms and vendor services. Pros The primary benefit of Terraform is that it is the default standard for integration with major Cloud providers, such that many of the new platform features are available first in Terraform. Strong Open Source community supporting multiple provider implementations for major and niche platforms and services. Extensible to support custom provider implementations to suit most needs Concise language well suited to infrastructure definition Cons Terraform alone is usually not sufficient to provide a complete Infrastructure as Code solution, but can be the cornerstone in a broader strategy. Infrastructure state is not managed automatically (Terraform Cloud does improve this) Some values may be stored in state insecurely (e.g. secrets, credentials, etc.) Module Guidelines Figurate modules are developed with the following principles for maximum portability and reuse. Use consistent variable names where possible (use same convention as resources) Make no assumptions about provider and backend configuration (these are configured externally) Avoid nested modules (minimise externally managed dependencies) Make no assumptions about execution environment (avoid local-exec) Figurate Modules Alerting | API Gateway | Audit Trail | Autoscaling | Backups | Budgets | Cache | Canary Deployments | CDN | Cell-based Architecture | Certificates | Containers | Service Discovery | Encryption | Events | Health Checks | Identity Management | Immutable Infrastructure | Lifecycle Policies | Load Balancing | Logging | Monitoring | Private Networking | Observability | Patching | Permissions | Proxies | Queues | Service Quotas | Recovery | Routing | Runbooks | Secrets | Serverless | Tenancy Management | Testing | Threat Detection | Throttling | Tracing | Usage Monitoring | Vulnerabilty Scans Alerting AWS Cloudwatch Alarms AWS SNS Topics API Gateway AWS Lambda APIs AWS API Gateway Targets Audit Trail TBD. Autoscaling AWS Autoscaling Groups AWS Launch Templates Backups TBD. Budgets TBD. Cache TBD. Canary Deployments TBD. CDN DigitalOcean CDN AWS CloudFront Distribution Cell-based Architecture TBD. Certificates AWS ACM Certificates Containers AWS ECS Clusters AWS ECS Services AWS ECS Task Definitions AWS ECR Repositories AWS ECS Capacity Providers Service Discovery AWS Service Discovery Namespaces Encryption AWS KMS Keys Events AWS S3 Triggers AWS CloudWatch Events Health Checks TBD. Identity Management TBD. Immutable Infrastructure TBD. Lifecycle Policies TBD. Load Balancing AWS Load Balancing Logging TBD. Monitoring TBD. Private Networking AWS VPC Subnets AWS VPC Endpoints AWS Security Groups DigitalOcean Firewalls Observability TBD. Patching TBD. Permissions AWS IAM Roles AWS IAM Groups AWS IAM Policies Proxies TBD. Queues TBD. Service Quotas TBD. Recovery TBD. Routing AWS Route53 Zones Runbooks TBD. Secrets AWS SSM Parameters Serverless AWS Lambda Layers AWS Lambda Functions Tenancy Management Github Repositories Github Organizations Terraform Cloud Organizations Terraform Cloud Workspaces AWS Organizations Policies Testing TBD. Threat Detection TBD. Throttling TBD. Tracing TBD. Usage Monitoring TBD. Vulnerability Scans TBD.","title":"Figurate Terraform"},{"location":"terraform/#figurate-terraform","text":"","title":"Figurate Terraform"},{"location":"terraform/#introduction","text":"Terraform is an infrastructure provisioning tool that defines a language that allows for declarative definition of infrastructure resources in a concise format. The power of Terraform is in the extensive list of provider plugins that implement integration with multiple Cloud platforms and vendor services.","title":"Introduction"},{"location":"terraform/#pros","text":"The primary benefit of Terraform is that it is the default standard for integration with major Cloud providers, such that many of the new platform features are available first in Terraform. Strong Open Source community supporting multiple provider implementations for major and niche platforms and services. Extensible to support custom provider implementations to suit most needs Concise language well suited to infrastructure definition","title":"Pros"},{"location":"terraform/#cons","text":"Terraform alone is usually not sufficient to provide a complete Infrastructure as Code solution, but can be the cornerstone in a broader strategy. Infrastructure state is not managed automatically (Terraform Cloud does improve this) Some values may be stored in state insecurely (e.g. secrets, credentials, etc.)","title":"Cons"},{"location":"terraform/#module-guidelines","text":"Figurate modules are developed with the following principles for maximum portability and reuse. Use consistent variable names where possible (use same convention as resources) Make no assumptions about provider and backend configuration (these are configured externally) Avoid nested modules (minimise externally managed dependencies) Make no assumptions about execution environment (avoid local-exec)","title":"Module Guidelines"},{"location":"terraform/#figurate-modules","text":"Alerting | API Gateway | Audit Trail | Autoscaling | Backups | Budgets | Cache | Canary Deployments | CDN | Cell-based Architecture | Certificates | Containers | Service Discovery | Encryption | Events | Health Checks | Identity Management | Immutable Infrastructure | Lifecycle Policies | Load Balancing | Logging | Monitoring | Private Networking | Observability | Patching | Permissions | Proxies | Queues | Service Quotas | Recovery | Routing | Runbooks | Secrets | Serverless | Tenancy Management | Testing | Threat Detection | Throttling | Tracing | Usage Monitoring | Vulnerabilty Scans","title":"Figurate Modules"},{"location":"terraform/#alerting","text":"AWS Cloudwatch Alarms AWS SNS Topics","title":"Alerting"},{"location":"terraform/#api-gateway","text":"AWS Lambda APIs AWS API Gateway Targets","title":"API Gateway"},{"location":"terraform/#audit-trail","text":"TBD.","title":"Audit Trail"},{"location":"terraform/#autoscaling","text":"AWS Autoscaling Groups AWS Launch Templates","title":"Autoscaling"},{"location":"terraform/#backups","text":"TBD.","title":"Backups"},{"location":"terraform/#budgets","text":"TBD.","title":"Budgets"},{"location":"terraform/#cache","text":"TBD.","title":"Cache"},{"location":"terraform/#canary-deployments","text":"TBD.","title":"Canary Deployments"},{"location":"terraform/#cdn","text":"DigitalOcean CDN AWS CloudFront Distribution","title":"CDN"},{"location":"terraform/#cell-based-architecture","text":"TBD.","title":"Cell-based Architecture"},{"location":"terraform/#certificates","text":"AWS ACM Certificates","title":"Certificates"},{"location":"terraform/#containers","text":"AWS ECS Clusters AWS ECS Services AWS ECS Task Definitions AWS ECR Repositories AWS ECS Capacity Providers","title":"Containers"},{"location":"terraform/#service-discovery","text":"AWS Service Discovery Namespaces","title":"Service Discovery"},{"location":"terraform/#encryption","text":"AWS KMS Keys","title":"Encryption"},{"location":"terraform/#events","text":"AWS S3 Triggers AWS CloudWatch Events","title":"Events"},{"location":"terraform/#health-checks","text":"TBD.","title":"Health Checks"},{"location":"terraform/#identity-management","text":"TBD.","title":"Identity Management"},{"location":"terraform/#immutable-infrastructure","text":"TBD.","title":"Immutable Infrastructure"},{"location":"terraform/#lifecycle-policies","text":"TBD.","title":"Lifecycle Policies"},{"location":"terraform/#load-balancing","text":"AWS Load Balancing","title":"Load Balancing"},{"location":"terraform/#logging","text":"TBD.","title":"Logging"},{"location":"terraform/#monitoring","text":"TBD.","title":"Monitoring"},{"location":"terraform/#private-networking","text":"AWS VPC Subnets AWS VPC Endpoints AWS Security Groups DigitalOcean Firewalls","title":"Private Networking"},{"location":"terraform/#observability","text":"TBD.","title":"Observability"},{"location":"terraform/#patching","text":"TBD.","title":"Patching"},{"location":"terraform/#permissions","text":"AWS IAM Roles AWS IAM Groups AWS IAM Policies","title":"Permissions"},{"location":"terraform/#proxies","text":"TBD.","title":"Proxies"},{"location":"terraform/#queues","text":"TBD.","title":"Queues"},{"location":"terraform/#service-quotas","text":"TBD.","title":"Service Quotas"},{"location":"terraform/#recovery","text":"TBD.","title":"Recovery"},{"location":"terraform/#routing","text":"AWS Route53 Zones","title":"Routing"},{"location":"terraform/#runbooks","text":"TBD.","title":"Runbooks"},{"location":"terraform/#secrets","text":"AWS SSM Parameters","title":"Secrets"},{"location":"terraform/#serverless","text":"AWS Lambda Layers AWS Lambda Functions","title":"Serverless"},{"location":"terraform/#tenancy-management","text":"Github Repositories Github Organizations Terraform Cloud Organizations Terraform Cloud Workspaces AWS Organizations Policies","title":"Tenancy Management"},{"location":"terraform/#testing","text":"TBD.","title":"Testing"},{"location":"terraform/#threat-detection","text":"TBD.","title":"Threat Detection"},{"location":"terraform/#throttling","text":"TBD.","title":"Throttling"},{"location":"terraform/#tracing","text":"TBD.","title":"Tracing"},{"location":"terraform/#usage-monitoring","text":"TBD.","title":"Usage Monitoring"},{"location":"terraform/#vulnerability-scans","text":"TBD.","title":"Vulnerability Scans"},{"location":"terraform/aws/","text":"Amazon Web Services (AWS) Support for AWS in Terraform is probably greater than any other platform. The modules below look at providing standard modules for common AWS components. Identity and Access Management (IAM) IAM manages roles and permissions for human and programmatic access to resources. IAM Permissions TBD. IAM Role TBD. IAM User TBD. Elastic Cloud Compute (EC2) EC2 is the cornerstone of compute infrastructure in AWS. As such there are a number of useful blueprints we can define that are applicable for reuse across many architectures. Launch Template TBD. Load Balancer TBD. Spot Fleet TBD. Elastic Container Registry (ECR) ECR provides storage for container images used across different container platforms. ECR Repository TBD. Elastic Container Service (ECS) ECS is a native AWS container platform that provides tight integration with the AWS platform. Capacity Provider TBD. Task Definition TBD.","title":"Amazon Web Services (AWS)"},{"location":"terraform/aws/#amazon-web-services-aws","text":"Support for AWS in Terraform is probably greater than any other platform. The modules below look at providing standard modules for common AWS components.","title":"Amazon Web Services (AWS)"},{"location":"terraform/aws/#identity-and-access-management-iam","text":"IAM manages roles and permissions for human and programmatic access to resources.","title":"Identity and Access Management (IAM)"},{"location":"terraform/aws/#iam-permissions","text":"TBD.","title":"IAM Permissions"},{"location":"terraform/aws/#iam-role","text":"TBD.","title":"IAM Role"},{"location":"terraform/aws/#iam-user","text":"TBD.","title":"IAM User"},{"location":"terraform/aws/#elastic-cloud-compute-ec2","text":"EC2 is the cornerstone of compute infrastructure in AWS. As such there are a number of useful blueprints we can define that are applicable for reuse across many architectures.","title":"Elastic Cloud Compute (EC2)"},{"location":"terraform/aws/#launch-template","text":"TBD.","title":"Launch Template"},{"location":"terraform/aws/#load-balancer","text":"TBD.","title":"Load Balancer"},{"location":"terraform/aws/#spot-fleet","text":"TBD.","title":"Spot Fleet"},{"location":"terraform/aws/#elastic-container-registry-ecr","text":"ECR provides storage for container images used across different container platforms.","title":"Elastic Container Registry (ECR)"},{"location":"terraform/aws/#ecr-repository","text":"TBD.","title":"ECR Repository"},{"location":"terraform/aws/#elastic-container-service-ecs","text":"ECS is a native AWS container platform that provides tight integration with the AWS platform.","title":"Elastic Container Service (ECS)"},{"location":"terraform/aws/#capacity-provider","text":"TBD.","title":"Capacity Provider"},{"location":"terraform/aws/#task-definition","text":"TBD.","title":"Task Definition"},{"location":"tools/ansible/","text":"Figurate Ansible TBD.","title":"Figurate Ansible"},{"location":"tools/ansible/#figurate-ansible","text":"TBD.","title":"Figurate Ansible"},{"location":"tools/cdk/","text":"Figurate CDK TBD.","title":"Figurate CDK"},{"location":"tools/cdk/#figurate-cdk","text":"TBD.","title":"Figurate CDK"},{"location":"tools/docker/","text":"Figurate Docker TBD.","title":"Figurate Docker"},{"location":"tools/docker/#figurate-docker","text":"TBD.","title":"Figurate Docker"}]}